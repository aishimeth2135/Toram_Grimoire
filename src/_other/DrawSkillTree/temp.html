<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <textarea id="a"></textarea><br />
    <span id="b">轉換</span><br />
    <div id="c"></div>
    <script>
        const Cyteria = {
            element: {
                remove(){
                    Array.from(arguments).forEach(node => {
                        if ( node )
                            node.parentNode.removeChild(node);
                    });
                },
                removeAllChild(node){
                    if ( !node ) return;
                    while ( node.firstChild )
                        node.removeChild(node.firstChild);
                    return node;
                },
                setAttributes(ele, dict){
                    Object.keys(dict).forEach(k => {
                        if ( dict[k] !== null )
                            ele.setAttribute(k, dict[k])
                    });
                },
                simpleCreateHTML(type, classList, html, attr){
                    const t = document.createElement(type);
                    if ( classList !== undefined && classList !== null ){
                        Array.isArray(classList) ? t.classList.add(...classList): t.classList.add(classList);
                    }
                    if ( html !== undefined && html !== null )
                        t.innerHTML = html;
                    if ( attr !== undefined && attr !== null )
                        Cyteria.element.setAttributes(t, attr);
                    return t;
                },
                convertRemToPixels(rem){    
                    return rem*parseFloat(getComputedStyle(document.documentElement).fontSize);
                }
            },
            svg: {
                create(width, height, attr={}){
                    const svg = document.createElementNS("http://www.w3.org/2000/svg", 'svg');
                    attr = Object.assign({
                        xmlns: "http://www.w3.org/2000/svg",
                        width, height,
                        viewBox: `0 0 ${width} ${height}`
                    }, attr);
                    Cyteria.element.setAttributes(svg, attr);
                    return svg;
                },
                drawCircle(cx, cy, r, attr={}){
                    const circle = document.createElementNS("http://www.w3.org/2000/svg", 'circle');
                    attr = Object.assign({
                        cx, cy, r
                    }, attr);
                    Cyteria.element.setAttributes(circle, attr);
                    return circle;
                },
                drawLine(x1, y1, x2, y2, attr={}){
                    const line = document.createElementNS("http://www.w3.org/2000/svg", 'line');
                    attr = Object.assign({
                        x1, y1, x2, y2
                    }, attr);
                    Cyteria.element.setAttributes(line, attr);
                    return line;
                },
                drawPath(d, attr={}){
                    const path = document.createElementNS("http://www.w3.org/2000/svg", 'path');
                    attr = Object.assign({d}, attr);
                    Cyteria.element.setAttributes(path, attr);
                    return path;
                },
                drawSector(cx, cy, startR, endR, startAngle, endAngle, clockwise, attr={}){
                    const path = document.createElementNS("http://www.w3.org/2000/svg", 'path');
                    attr = Object.assign({
                        d: Cyteria.svg.getSectorD(cx, cy, startR, endR, startAngle, endAngle, clockwise),
                        fill: 'none'
                    }, attr);
                    Cyteria.element.setAttributes(path, attr);
                    return path;
                },
                getSectorD(cx, cy, startR, endR, startAngle , endAngle, clockwise){
                    const deg = Math.PI/180;
                    const ssx = startR*Math.cos(endAngle*deg) + cx,
                        ssy = -startR*Math.sin(endAngle*deg) + cy,
                        sex = startR*Math.cos(startAngle*deg) + cx,
                        sey = -startR*Math.sin(startAngle*deg) + cy,
                        esx = endR*Math.cos(startAngle*deg) + cx,
                        esy = -endR*Math.sin(startAngle*deg) + cy,
                        eex = endR*Math.cos(endAngle*deg) + cx,
                        eey = -endR*Math.sin(endAngle*deg) + cy;
                    return `M${ssx} ${ssy}A${startR} ${startR} 0 0 ${clockwise == 1 ? 0 : 1} ${sex} ${sey}L${esx} ${esy}A${endR} ${endR} 0 0 ${clockwise} ${eex} ${eey}Z`;
                },
                createAnimate(attributeName, attr={}){
                    attr = Object.assign({
                        attributeName,
                        repeatCount: 'indefinite'
                    }, attr);
                    const ani = document.createElementNS("http://www.w3.org/2000/svg", 'animate');
                    Cyteria.element.setAttributes(ani, attr);
                    return ani;
                }
            }
        };

        const CY = Cyteria;

        function DrawSkillTree(s){
        const w = 50, pad = 20;

        function tran(v){
            return pad + w/2 + v*w;
        }

        const Line = CY.svg.drawLine, Circle = CY.svg.drawCircle;

        const frg = document.createDocumentFragment();

        let x = 0, y = 0, maxw = 0;

        s.toUpperCase()
        .replace(/([A-Z])(\d+)/g, (m, w, d) => Array(parseInt(d, 10)).fill(w).join(' '))
        .split(' ')
        .forEach(p => {
            const c = p.charAt(0);
            switch (c){
                case 'L':
                    if ( x > maxw )
                        maxw = x;
                    x = 0;
                    ++y;
                    break;
                case 'E':
                    ++x;
                    break;
                case 'D': case 'S': {
                    p.slice(1).split('').forEach(t => {
                        let line;
                        if ( t === 'R' )
                            line = Line(tran(x), tran(y), tran(x+1), tran(y));
                        if ( t === 'B' )
                            line = Line(tran(x), tran(y), tran(x), tran(y+1));
                        frg.appendChild(line);
                    });
                    let t;
                    if ( c === 'D' )
                        t = Circle(tran(x), tran(y), 2, {class: 'dot'});
                    if ( c === 'S' )
                        t = Circle(tran(x), tran(y), w/2, {class: 'skill-circle'});
                    frg.appendChild(t);
                    ++x;
                } break;
                case 'H':
                    frg.appendChild(Line(tran(x), tran(y), tran(x+1), tran(y)));
                    ++x;
                    break;
                case 'V':
                    frg.appendChild(Line(tran(x), tran(y), tran(x), tran(y+1)));
                    ++x;
                    break;
            }
        });

        const he = CY.svg.create(tran(maxw) - w/2 + pad, tran(y) + w/2 + pad);
        he.appendChild(frg);

        return he;
    }
    const a = document.getElementById('a'),
        b = document.getElementById('b'),
        c = document.getElementById('c');
    b.addEventListener('click', function(e){
        try {
            c.innerHTML = '';
            c.appendChild(DrawSkillTree(a.value));
        }
        catch (e){
            c.innerHTML = e.stack;
        }
    });
    </script>
</body>
<style>
    :root {
        --primary-light: #FFD1EA;
        --primary-light-2: #ff5fb7;
        --primary-light-3: #ff008d;
    }
	
	#a {
		width: 30rem;
		height: 5rem;
		padding: 0.6rem;
		font-size: 1rem;
	}
	
	#b {
		display: inline-block;
		padding: 1rem;
		margin: 0.2rem;
		border: 1px var(--primary-light) solid;
		color: var(--primary-light-2);
		transition: 0.3s;
		cursor: pointer;
		text-align: center;
	}
	#b:hover {
		border-color: var(--primary-light-2);
	}
	
	#c {
		border: 1px var(--primary-light-2) solid;
		display: inline-block;
		padding: 0.4rem;
	}
	
    #c svg {
        stroke: var(--primary-light-2);
        stroke-width: 2px;
    }
    #c svg > circle.dot {
        fill: var(--primary-light-2);
    }
    #c svg > circle.skill-circle {
        fill: #FFF;
        z-index: 5;
    }
</style>
</html>